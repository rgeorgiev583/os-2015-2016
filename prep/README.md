# Задачи за подготовка за контролна работа

## Bash

* Напишете команда на Bash, която извежда броя на всички файлове с разширение `.log` в директорията `/var/log`.
* Напишете Bash скрипт, който за всеки (уникален) логнат потребител на системата убива всички процеси, които са били създадени от него.
  *Забележка:* Тук ще трябва да използвате `ps aux`, тъй като в `ps ax` не присъства колонката `USER`.
* Напишете Bash скрипт, който убива всички стартирани инстанции на процеси с имена, подадени като аргументи на командния ред.
* Напишете Bash скрипт, който извежда имената на n-те най-големи файла в дадена директория, като директорията и числото се подават като аргументи на командния ред.
* Напишете Bash скрипт, който компресира всички файлове в дадена директория с размер, по-голям от подадения на командния ред.
  *Забележка:* За компресия може да използвате командата `gzip FILE...`.
* Напишете Bash скрипт, който премества всички файлове в дадена директория с дата на последна промяна, по-ранна от подадената като аргумент на командния ред.
  *Забележка:* За да вземете датата на последна промяна във формат на Unix епоха (*Unix time*, т.е. брой изминали секунди след 00:00 часа на 01.01.1970 г.), използвайте `stat -c %Y FILE`.  За да конвертирате датата, подадена като аргумент, към същия формат, използвайте `date +%s -d DATE`, където *DATE* е въпросната дата.  Тъй като по този начин ще получите две числа, оттук нататък е лесно да ги сравните.
* Напишете Bash функция, която по даден път като аргумент връща (извежда) само името на файла без разширението (ако има такова).  Вложете функцията в скрипт, който приема като аргумент(и) файлове, на всеки ред от които има пътища, и извежда всички имена на файловете от съответните пътища на стандартния изход.
* Напишете Bash скрипт, който по подадени име на директория и две разширения на командния ред (например `.txt` и `.md`) преименува всички файлове в директорията, замествайки първото разширение с второто.
* Напишете Bash скрипт, който приема като аргументи файл(ове), които съдържат команди, събира (аритметично) резултатите от извикването им, и записва полученото число във файла, подаден като последен аргумент.
* Напишете Bash скрипт, който номерира непразните редове във файловете, подадени като аргументи на командния ред.  Номерацията трябва да започва отначало за всеки файл.
  *Например:* `fortune.txt` преди:

		Has anyone realized that the purpose of the fortune cookie program is to
        defuse project tensions?  When did you ever see a cheerful cookie, a
        non-cynical, or even an informative cookie?
        Perhaps inadvertently, we have a channel for our aggressions.  This
        still begs the question [sic] of whether the cookie releases the pressure or only
        serves to blunt the warning signs.

        Long live the revolution!
        Have a nice day.

  и след това:

		1. Has anyone realized that the purpose of the fortune cookie program is to
        2. defuse project tensions?  When did you ever see a cheerful cookie, a
        3. non-cynical, or even an informative cookie?
        4. Perhaps inadvertently, we have a channel for our aggressions.  This
        5. still begs the question [sic] of whether the cookie releases the pressure or only
        6. serves to blunt the warning signs.

        7. Long live the revolution!
        8. Have a nice day.

*Забележка:* Където съм писал "*всички файлове в дадена директория*", съм имал предвид, че при това се включват и поддиректориите ѝ.  Например ако имаме следната йерархия:

	/foo (dir)
    /foo/bar (dir)
    /foo/bar/quux
    /foo/bar/fuzz
    /foo/baz
    /foo/fizz (dir)
    /foo/fizz/lol (dir)
    /foo/fizz/lol/wut
    /foo/buzz (dir)

Тук под "*всички файлове*" да се разбира следното множество: {`/foo/bar/quux`, `/foo/bar/fuzz`, `/foo/baz`, `/foo/fizz/lol/wut`}.
Т.е. `ls DIR` и `for i in DIR/*` **НЯМА** да ви свършат работа в този случай, тъй като не поддържат рекурсия.

Неща, които е хубаво да се преговорят:
* Основните команди за работа с Unix
* Конвейер (*pipe*) между команди
* Стартиране на команди във фонов режим, `fg`, `bg`, *Ctrl+Z* и т.н.
* Командни процедури (*shell скриптове*): как се пишат, как се стартират и т.н.
* Променливи на средата (*environment variables*)
* Субституции (замествания, разширения) (всичко, започващо с `$`)
* Императивни конструкции: `if`, `for` (различните му варианти), `while`
* Функции: как се извикват

## C

Ще трябва да напишете опростена имплементация на някой (не по избор) от стандартните Unix инструменти (`cat`, `ls`, `grep`, `cut` и т.н.), така че си преговорете тези от тях, които сме учили.  Тъй като начинът на работа и точните аргументи и опции на всяка от командите, които са дадени като задачи, все пак ще бъдат описани подробно, то все пак може да се падне и такъв инструмент, който не сме разглеждали на упражнения.

Ще е добре да преговорите следните системни извиквания:
* `open` (със всичките му флагове, които сме учили)
* `creat` (режим на файл: припомнете си `chmod`)
* `read` (какво връща?)
* `write` (какво връща?)
* `close` (задължително ли трябва да се извиква всеки път при отваряне на файл?)
* `fork` (какво връща в родителя и детето?)
* `exec` (всичките му варианти, които сме разглеждали)
* `wait` (какво се съдържа в аргумента му; може ли да се извиква в детето и да изчаква родителя?)
* `exit` (каква е връзката между аргумента му и аргумента на `wait`?)